Main Method = The entry point of a Java program

public static void main(String[] args) {
        *CODE*
}

public = Needs to be public so that the JRE (Java Runtime Environment) can access and execute it.
static = Needs to be static so that the JVM can load the class into memory and call the main method without creating an instance of the class first.
void = Return type is void because the main function shouldn't return anything, when it finishes executing, the Java program simply terminates.
String[] args = accepts arguments from the command line that are stored in a String array to affect the operation of the program.


Data Structures = Named location used to store and organize data
Ex: Array = A collection of elements stores in contiguous memory locations.

Algorithm = A collection of steps to solve a problem
Ex: Linear Search = Examining the elements of an array one by one to find a value.

DATA STRUCTURES

STACK
LIFO data structure (Last in first out).
Stores objects as a "vertical tower", like a stack of books or cds.
push() method is used to add objects to the top.
pop() method is used to remove from the top.

QUEUE
FIFO data structure (First in first out)
A collection designed for holding elements prior to processing.
Linear data structure (a data structure that stores data sequentially)
Head = First element of the queue
Tail = Last element of the queue
enqueue = adding an object to the end of the queue
dequeue = removing an object from the head of the queue

PRIORITY QUEUE
A FIFO data structure that serves elements with the highest priority first before elements with lower priority
Its like a normal queue, but you sort the elements first based on a parameter, so you can serve the elements
with the highest priority first and work your way down to the lowest priority.

LINKED LISTS
Stores nodes in 2 parts (data + address)
Nodes are in non-consecutive memory locations, elements are linked using pointers

Singly LinkedList structure (Address points only to the next node)
     Node                 Node                Node
[data | address] ->  [data | address] -> [data | address]

Doubly LinkedList structure (Address points to the previous and next node)
           Node                            Node
[address | data | address] <->  [address | data | address]

Advantages:
1 - Dynamic Data Structure (allocates needed memory while running)
2 - Insertion and Deletion of Nodes is easy, 0(1) constant time complexity
3 - No/Low Memory Waste

Disadvantages:
1 - Greater memory usage(additional pointer for the address, even more so with a doubly linked list)
2 - No random access of elements (no index[i])
3 - Accessing/searching elements is more time-consuming 0(n) linear time complexity

Use examples:
1 - Implement Stacks and Queues
2 - GPS navigation
(If you have a starting position and a final destination, every stop along the way can be seen as a node,
 and changing the path is as simple as changing, inserting or deleting a node)
3 - Music Playlists

DYNAMIC ARRAYS

Static Array = new String[capacity];
Can access elements directly with 0(1) constant time, but searching takes more time the larger the amount of elements, O(n) linear time complexity.
Has a fixed capacity of elements.

Dynamic arrays have their own static array with a fixed size, but once its inner static array reaches capacity, a dynamic array will instantiate
a new array with an increased capacity, copying the elements over to the new array

Advantages:
1 - Random memory access
2 - Good data cache utilization due to contiguous memory addresses
3 - Easy to insert/delete at tail due to no shifting of elements

Disadvantages:
1 - Memory wastage compared to LinkedLists due to increases in array capacity to accommodate more elements not being the exact number of new elements
leading to null memory addresses
2 - Shifting of elements has O(n) linear time complexity due to all elements needing to be shifted to the left in case of a deletion, or to the right
in case of an insertion.
3 - Expanding/Shrinking the array has 0 (n) linear time complexity due to needing to copy all the elements over to a new array with a new capacity




